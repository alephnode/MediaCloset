package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"mediacloset/api/internal/graph/model"
	custommw "mediacloset/api/internal/middleware"
	"time"
)

// RequestLoginCode is the resolver for the requestLoginCode field.
func (r *mutationResolver) RequestLoginCode(ctx context.Context, email string) (*model.RequestLoginCodeResponse, error) {
	// Validate email format (basic check)
	if email == "" {
		return &model.RequestLoginCodeResponse{
			Success: false,
			Error:   &[]string{"Email is required"}[0],
		}, nil
	}

	err := r.AuthService.RequestLoginCode(ctx, email)
	if err != nil {
		return &model.RequestLoginCodeResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to request login code: %v", err)}[0],
		}, nil
	}

	return &model.RequestLoginCodeResponse{
		Success: true,
		Message: "Login code sent to your email",
	}, nil
}

// VerifyLoginCode is the resolver for the verifyLoginCode field.
func (r *mutationResolver) VerifyLoginCode(ctx context.Context, email string, code string) (*model.VerifyLoginCodeResponse, error) {
	// Validate inputs
	if email == "" {
		return &model.VerifyLoginCodeResponse{
			Success: false,
			Error:   &[]string{"Email is required"}[0],
		}, nil
	}
	if code == "" {
		return &model.VerifyLoginCodeResponse{
			Success: false,
			Error:   &[]string{"Code is required"}[0],
		}, nil
	}

	token, user, err := r.AuthService.VerifyLoginCode(ctx, email, code)
	if err != nil {
		return &model.VerifyLoginCodeResponse{
			Success: false,
			Error:   &[]string{err.Error()}[0],
		}, nil
	}

	return &model.VerifyLoginCodeResponse{
		Success: true,
		Token:   &token,
		User: &model.User{
			ID:        user.ID,
			Email:     user.Email,
			CreatedAt: user.CreatedAt.Format(time.RFC3339),
			UpdatedAt: user.UpdatedAt.Format(time.RFC3339),
		},
	}, nil
}

// SaveMovie is the resolver for the saveMovie field.
func (r *mutationResolver) SaveMovie(ctx context.Context, input model.SaveMovieInput) (*model.SaveMovieResponse, error) {
	// Check authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	// Validate required fields
	if input.Title == "" {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{"Title is required"}[0],
		}, nil
	}

	// Validate year if provided
	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveMovieResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch poster from OMDB
		movieData, err := r.OMDBService.SearchMovie(ctx, input.Title, input.Director, input.Year)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveMovie] Failed to fetch poster for '%s': %v\n", input.Title, err)
		} else if movieData != nil && movieData.PosterURL != nil {
			coverURL = *movieData.PosterURL
			fmt.Printf("[SaveMovie] Auto-fetched poster for '%s' from %s\n", input.Title, movieData.Source)
		} else {
			fmt.Printf("[SaveMovie] No poster found for '%s'\n", input.Title)
		}
	}

	// Check if movie already exists (many-to-many: don't duplicate movies)
	var vhsID string
	existingMovie, err := r.HasuraClient.FindMovieByTitle(ctx, input.Title, input.Director, input.Year)
	if err != nil {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check for existing movie: %v", err)}[0],
		}, nil
	}

	if existingMovie != nil {
		// Movie exists, use its ID
		if id, ok := existingMovie["id"].(string); ok {
			vhsID = id
		}
	} else {
		// Movie doesn't exist, create it
		vhs := map[string]interface{}{
			"title": input.Title,
		}

		if input.Director != nil {
			vhs["director"] = *input.Director
		}
		if input.Year != nil {
			vhs["year"] = *input.Year
		}
		if input.Genre != nil {
			vhs["genre"] = *input.Genre
		}
		if coverURL != "" {
			vhs["cover_url"] = coverURL
		}

		// Create the movie
		createdID, err := r.HasuraClient.InsertVHS(ctx, vhs)
		if err != nil {
			return &model.SaveMovieResponse{
				Success: false,
				Error:   &[]string{fmt.Sprintf("Failed to create movie: %v", err)}[0],
			}, nil
		}
		vhsID = createdID
	}

	// Link movie to user via junction table (many-to-many)
	err = r.HasuraClient.LinkMovieToUser(ctx, userInfo.UserID, vhsID)
	if err != nil {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to add movie to collection: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveMovieResponse{
		Success: true,
		Movie: &model.SavedMovie{
			ID:       0, // ID not returned by Hasura
			Title:    input.Title,
			Director: input.Director,
			Year:     input.Year,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// UpdateMovie is the resolver for the updateMovie field.
func (r *mutationResolver) UpdateMovie(ctx context.Context, id string, input model.UpdateMovieInput) (*model.UpdateMovieResponse, error) {
	// Check authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	// Verify ownership via junction table
	owns, err := r.HasuraClient.CheckMovieOwnership(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check ownership: %v", err)}[0],
		}, nil
	}
	if !owns {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{"Not authorized to update this movie"}[0],
		}, nil
	}

	// Get movie for response
	movie, err := r.HasuraClient.GetMovieByID(ctx, id)
	if err != nil {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to fetch movie: %v", err)}[0],
		}, nil
	}
	if movie == nil {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{"Movie not found"}[0],
		}, nil
	}

	// Build updates map
	updates := make(map[string]interface{})

	if input.Title != nil {
		updates["title"] = *input.Title
	}
	if input.Director != nil {
		updates["director"] = *input.Director
	}
	if input.Year != nil {
		updates["year"] = *input.Year
	}
	if input.Genre != nil {
		updates["genre"] = *input.Genre
	}
	if input.CoverURL != nil {
		updates["cover_url"] = *input.CoverURL
	}

	// Update in Hasura
	movieData, err := r.HasuraClient.UpdateMovie(ctx, id, updates)
	if err != nil {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to update movie: %v", err)}[0],
		}, nil
	}

	// Convert to model.Movie
	movieModel := &model.Movie{}
	if movieID, ok := movieData["id"].(string); ok {
		movieModel.ID = movieID
	}
	if title, ok := movieData["title"].(string); ok {
		movieModel.Title = title
	}
	if director, ok := movieData["director"].(string); ok {
		movieModel.Director = &director
	}
	if year, ok := movieData["year"].(float64); ok {
		yearInt := int(year)
		movieModel.Year = &yearInt
	}
	if genre, ok := movieData["genre"].(string); ok {
		movieModel.Genre = &genre
	}
	if coverURL, ok := movieData["cover_url"].(string); ok {
		movieModel.CoverURL = &coverURL
	}
	if createdAt, ok := movieData["created_at"].(string); ok {
		movieModel.CreatedAt = &createdAt
	}
	if updatedAt, ok := movieData["updated_at"].(string); ok {
		movieModel.UpdatedAt = &updatedAt
	}

	return &model.UpdateMovieResponse{
		Success: true,
		Movie:   movieModel,
	}, nil
}

// DeleteMovie is the resolver for the deleteMovie field.
func (r *mutationResolver) DeleteMovie(ctx context.Context, id string) (*model.DeleteResponse, error) {
	// Check authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	// Verify ownership via junction table
	owns, err := r.HasuraClient.CheckMovieOwnership(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check ownership: %v", err)}[0],
		}, nil
	}
	if !owns {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{"Not authorized to remove this movie from your collection"}[0],
		}, nil
	}

	// Remove from user's collection (unlink, don't delete the movie itself)
	err = r.HasuraClient.UnlinkMovieFromUser(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to delete movie: %v", err)}[0],
		}, nil
	}

	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// SaveAlbum is the resolver for the saveAlbum field.
func (r *mutationResolver) SaveAlbum(ctx context.Context, input model.SaveAlbumInput) (*model.SaveAlbumResponse, error) {
	// Check authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	// Validate required fields
	if input.Artist == "" {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Artist is required"}[0],
		}, nil
	}
	if input.Album == "" {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Album is required"}[0],
		}, nil
	}

	// Validate year if provided
	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveAlbumResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch cover art from MusicBrainz
		albumData, err := r.MusicBrainz.SearchAlbum(ctx, input.Artist, input.Album)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveAlbum] Failed to fetch cover for '%s - %s': %v\n", input.Artist, input.Album, err)
		} else if albumData != nil && albumData.CoverURL != nil {
			coverURL = *albumData.CoverURL
			fmt.Printf("[SaveAlbum] Auto-fetched cover for '%s - %s' from %s\n", input.Artist, input.Album, albumData.Source)
		} else {
			fmt.Printf("[SaveAlbum] No cover found for '%s - %s'\n", input.Artist, input.Album)
		}
	}

	// Check if record already exists (many-to-many: don't duplicate albums)
	var recordID string
	existingRecord, err := r.HasuraClient.FindRecordByArtistAlbum(ctx, input.Artist, input.Album)
	if err != nil {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check for existing album: %v", err)}[0],
		}, nil
	}

	if existingRecord != nil {
		// Record exists, use its ID
		if id, ok := existingRecord["id"].(string); ok {
			recordID = id
		}

		// Update the existing record with any new information from the input
		updates := map[string]interface{}{}

		// Update cover URL if we fetched a new one and the existing record doesn't have one
		existingCoverURL, _ := existingRecord["cover_url"].(string)
		if coverURL != "" && existingCoverURL == "" {
			updates["cover_url"] = coverURL
		}

		// Update color variants if provided in the input
		if len(input.ColorVariants) > 0 {
			updates["color_variants"] = input.ColorVariants
		}

		// Update genres if provided in the input
		if len(input.Genres) > 0 {
			updates["genres"] = input.Genres
		}

		// Update size if provided in the input
		if input.Size != nil {
			updates["size"] = *input.Size
		}

		if len(updates) > 0 {
			_, err := r.HasuraClient.UpdateAlbum(ctx, recordID, updates)
			if err != nil {
				fmt.Printf("[SaveAlbum] Failed to update existing album '%s - %s': %v\n", input.Artist, input.Album, err)
			} else {
				fmt.Printf("[SaveAlbum] Updated existing album '%s - %s'\n", input.Artist, input.Album)
			}
		}
	} else {
		// Record doesn't exist, create it
		record := map[string]interface{}{
			"artist": input.Artist,
			"album":  input.Album,
		}

		if input.Year != nil {
			record["year"] = *input.Year
		}
		if input.Label != nil {
			record["label"] = *input.Label
		}
		if len(input.ColorVariants) > 0 {
			record["color_variants"] = input.ColorVariants
		}
		if len(input.Genres) > 0 {
			record["genres"] = input.Genres
		}
		if input.Size != nil {
			record["size"] = *input.Size
		}
		if coverURL != "" {
			record["cover_url"] = coverURL
		}

		// Create the record
		createdID, err := r.HasuraClient.InsertRecord(ctx, record)
		if err != nil {
			return &model.SaveAlbumResponse{
				Success: false,
				Error:   &[]string{fmt.Sprintf("Failed to create album: %v", err)}[0],
			}, nil
		}
		recordID = createdID
	}

	// Link record to user via junction table (many-to-many)
	err = r.HasuraClient.LinkRecordToUser(ctx, userInfo.UserID, recordID)
	if err != nil {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to add album to collection: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveAlbumResponse{
		Success: true,
		Album: &model.SavedAlbum{
			ID:            0, // ID not returned by Hasura
			Artist:        input.Artist,
			Album:         input.Album,
			Year:          input.Year,
			Label:         input.Label,
			ColorVariants: input.ColorVariants,
			Genres:        input.Genres,
			CoverURL:      &coverURL,
			Size:          input.Size,
		},
	}, nil
}

// UpdateAlbum is the resolver for the updateAlbum field.
func (r *mutationResolver) UpdateAlbum(ctx context.Context, id string, input model.UpdateAlbumInput) (*model.UpdateAlbumResponse, error) {
	// Check authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	// Verify ownership via junction table
	owns, err := r.HasuraClient.CheckRecordOwnership(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check ownership: %v", err)}[0],
		}, nil
	}
	if !owns {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{"Not authorized to update this album"}[0],
		}, nil
	}

	// Get album for response
	album, err := r.HasuraClient.GetAlbumByID(ctx, id)
	if err != nil {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to fetch album: %v", err)}[0],
		}, nil
	}
	if album == nil {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{"Album not found"}[0],
		}, nil
	}

	// Build updates map
	updates := make(map[string]interface{})

	if input.Artist != nil {
		updates["artist"] = *input.Artist
	}
	if input.Album != nil {
		updates["album"] = *input.Album
	}
	if input.Year != nil {
		updates["year"] = *input.Year
	}
	if input.Label != nil {
		updates["label"] = *input.Label
	}
	if len(input.ColorVariants) > 0 {
		updates["color_variants"] = input.ColorVariants
	}
	if len(input.Genres) > 0 {
		updates["genres"] = input.Genres
	}
	if input.CoverURL != nil {
		updates["cover_url"] = *input.CoverURL
	}
	if input.Size != nil {
		updates["size"] = *input.Size
	}

	// Update in Hasura
	albumData, err := r.HasuraClient.UpdateAlbum(ctx, id, updates)
	if err != nil {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to update album: %v", err)}[0],
		}, nil
	}

	// Convert to model.Album
	albumModel := &model.Album{}
	if albumID, ok := albumData["id"].(string); ok {
		albumModel.ID = albumID
	}
	if artist, ok := albumData["artist"].(string); ok {
		albumModel.Artist = artist
	}
	if albumName, ok := albumData["album"].(string); ok {
		albumModel.Album = albumName
	}
	if year, ok := albumData["year"].(float64); ok {
		yearInt := int(year)
		albumModel.Year = &yearInt
	}
	if label, ok := albumData["label"].(string); ok {
		albumModel.Label = &label
	}
	if colorVariants, ok := albumData["color_variants"].([]interface{}); ok {
		variantStrs := make([]string, 0, len(colorVariants))
		for _, v := range colorVariants {
			if variantStr, ok := v.(string); ok {
				variantStrs = append(variantStrs, variantStr)
			}
		}
		if len(variantStrs) > 0 {
			albumModel.ColorVariants = variantStrs
		}
	}
	if genres, ok := albumData["genres"].([]interface{}); ok {
		genreStrs := make([]string, 0, len(genres))
		for _, g := range genres {
			if genreStr, ok := g.(string); ok {
				genreStrs = append(genreStrs, genreStr)
			}
		}
		if len(genreStrs) > 0 {
			albumModel.Genres = genreStrs
		}
	}
	if coverURL, ok := albumData["cover_url"].(string); ok {
		albumModel.CoverURL = &coverURL
	}
	if size, ok := albumData["size"].(float64); ok {
		sizeInt := int(size)
		albumModel.Size = &sizeInt
	}
	if createdAt, ok := albumData["created_at"].(string); ok {
		albumModel.CreatedAt = &createdAt
	}
	if updatedAt, ok := albumData["updated_at"].(string); ok {
		albumModel.UpdatedAt = &updatedAt
	}

	return &model.UpdateAlbumResponse{
		Success: true,
		Album:   albumModel,
	}, nil
}

// DeleteAlbum is the resolver for the deleteAlbum field.
func (r *mutationResolver) DeleteAlbum(ctx context.Context, id string) (*model.DeleteResponse, error) {
	// Check authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	// Verify ownership via junction table
	owns, err := r.HasuraClient.CheckRecordOwnership(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check ownership: %v", err)}[0],
		}, nil
	}
	if !owns {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{"Not authorized to remove this album from your collection"}[0],
		}, nil
	}

	// Remove from user's collection (unlink, don't delete the album itself)
	err = r.HasuraClient.UnlinkRecordFromUser(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to delete album: %v", err)}[0],
		}, nil
	}

	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// SaveCassette is the resolver for the saveCassette field.
func (r *mutationResolver) SaveCassette(ctx context.Context, input model.SaveCassetteInput) (*model.SaveCassetteResponse, error) {
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.SaveCassetteResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	if input.Artist == "" {
		return &model.SaveCassetteResponse{
			Success: false,
			Error:   &[]string{"Artist is required"}[0],
		}, nil
	}
	if input.Album == "" {
		return &model.SaveCassetteResponse{
			Success: false,
			Error:   &[]string{"Album is required"}[0],
		}, nil
	}

	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveCassetteResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		albumData, err := r.MusicBrainz.SearchAlbum(ctx, input.Artist, input.Album)
		if err != nil {
			fmt.Printf("[SaveCassette] Failed to fetch cover for '%s - %s': %v\n", input.Artist, input.Album, err)
		} else if albumData != nil && albumData.CoverURL != nil {
			coverURL = *albumData.CoverURL
			fmt.Printf("[SaveCassette] Auto-fetched cover for '%s - %s' from %s\n", input.Artist, input.Album, albumData.Source)
		} else {
			fmt.Printf("[SaveCassette] No cover found for '%s - %s'\n", input.Artist, input.Album)
		}
	}

	var cassetteID string
	existingCassette, err := r.HasuraClient.FindCassetteByArtistAlbum(ctx, input.Artist, input.Album)
	if err != nil {
		return &model.SaveCassetteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check for existing cassette: %v", err)}[0],
		}, nil
	}

	if existingCassette != nil {
		if id, ok := existingCassette["id"].(string); ok {
			cassetteID = id
		}

		updates := map[string]interface{}{}
		existingCoverURL, _ := existingCassette["cover_url"].(string)
		if coverURL != "" && existingCoverURL == "" {
			updates["cover_url"] = coverURL
		}
		if len(input.Genres) > 0 {
			updates["genres"] = input.Genres
		}
		if input.TapeType != nil {
			updates["tape_type"] = *input.TapeType
		}

		if len(updates) > 0 {
			_, err := r.HasuraClient.UpdateCassette(ctx, cassetteID, updates)
			if err != nil {
				fmt.Printf("[SaveCassette] Failed to update existing cassette '%s - %s': %v\n", input.Artist, input.Album, err)
			}
		}
	} else {
		cassette := map[string]interface{}{
			"artist": input.Artist,
			"album":  input.Album,
		}

		if input.Year != nil {
			cassette["year"] = *input.Year
		}
		if input.Label != nil {
			cassette["label"] = *input.Label
		}
		if len(input.Genres) > 0 {
			cassette["genres"] = input.Genres
		}
		if input.TapeType != nil {
			cassette["tape_type"] = *input.TapeType
		}
		if coverURL != "" {
			cassette["cover_url"] = coverURL
		}

		createdID, err := r.HasuraClient.InsertCassette(ctx, cassette)
		if err != nil {
			return &model.SaveCassetteResponse{
				Success: false,
				Error:   &[]string{fmt.Sprintf("Failed to create cassette: %v", err)}[0],
			}, nil
		}
		cassetteID = createdID
	}

	err = r.HasuraClient.LinkCassetteToUser(ctx, userInfo.UserID, cassetteID)
	if err != nil {
		return &model.SaveCassetteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to add cassette to collection: %v", err)}[0],
		}, nil
	}

	return &model.SaveCassetteResponse{
		Success: true,
		Cassette: &model.SavedCassette{
			ID:       0,
			Artist:   input.Artist,
			Album:    input.Album,
			Year:     input.Year,
			Label:    input.Label,
			Genres:   input.Genres,
			CoverURL: &coverURL,
			TapeType: input.TapeType,
		},
	}, nil
}

// UpdateCassette is the resolver for the updateCassette field.
func (r *mutationResolver) UpdateCassette(ctx context.Context, id string, input model.UpdateCassetteInput) (*model.UpdateCassetteResponse, error) {
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.UpdateCassetteResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	owns, err := r.HasuraClient.CheckCassetteOwnership(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.UpdateCassetteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check ownership: %v", err)}[0],
		}, nil
	}
	if !owns {
		return &model.UpdateCassetteResponse{
			Success: false,
			Error:   &[]string{"Not authorized to update this cassette"}[0],
		}, nil
	}

	cassette, err := r.HasuraClient.GetCassetteByID(ctx, id)
	if err != nil {
		return &model.UpdateCassetteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to fetch cassette: %v", err)}[0],
		}, nil
	}
	if cassette == nil {
		return &model.UpdateCassetteResponse{
			Success: false,
			Error:   &[]string{"Cassette not found"}[0],
		}, nil
	}

	updates := make(map[string]interface{})

	if input.Artist != nil {
		updates["artist"] = *input.Artist
	}
	if input.Album != nil {
		updates["album"] = *input.Album
	}
	if input.Year != nil {
		updates["year"] = *input.Year
	}
	if input.Label != nil {
		updates["label"] = *input.Label
	}
	if len(input.Genres) > 0 {
		updates["genres"] = input.Genres
	}
	if input.CoverURL != nil {
		updates["cover_url"] = *input.CoverURL
	}
	if input.TapeType != nil {
		updates["tape_type"] = *input.TapeType
	}

	cassetteData, err := r.HasuraClient.UpdateCassette(ctx, id, updates)
	if err != nil {
		return &model.UpdateCassetteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to update cassette: %v", err)}[0],
		}, nil
	}

	cassetteModel := &model.Cassette{}
	if cassetteID, ok := cassetteData["id"].(string); ok {
		cassetteModel.ID = cassetteID
	}
	if artist, ok := cassetteData["artist"].(string); ok {
		cassetteModel.Artist = artist
	}
	if albumName, ok := cassetteData["album"].(string); ok {
		cassetteModel.Album = albumName
	}
	if year, ok := cassetteData["year"].(float64); ok {
		yearInt := int(year)
		cassetteModel.Year = &yearInt
	}
	if label, ok := cassetteData["label"].(string); ok {
		cassetteModel.Label = &label
	}
	if genres, ok := cassetteData["genres"].([]interface{}); ok {
		genreStrs := make([]string, 0, len(genres))
		for _, g := range genres {
			if genreStr, ok := g.(string); ok {
				genreStrs = append(genreStrs, genreStr)
			}
		}
		if len(genreStrs) > 0 {
			cassetteModel.Genres = genreStrs
		}
	}
	if coverURL, ok := cassetteData["cover_url"].(string); ok {
		cassetteModel.CoverURL = &coverURL
	}
	if tapeType, ok := cassetteData["tape_type"].(string); ok {
		cassetteModel.TapeType = &tapeType
	}
	if createdAt, ok := cassetteData["created_at"].(string); ok {
		cassetteModel.CreatedAt = &createdAt
	}
	if updatedAt, ok := cassetteData["updated_at"].(string); ok {
		cassetteModel.UpdatedAt = &updatedAt
	}

	return &model.UpdateCassetteResponse{
		Success:  true,
		Cassette: cassetteModel,
	}, nil
}

// DeleteCassette is the resolver for the deleteCassette field.
func (r *mutationResolver) DeleteCassette(ctx context.Context, id string) (*model.DeleteResponse, error) {
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{"Authentication required"}[0],
		}, nil
	}

	owns, err := r.HasuraClient.CheckCassetteOwnership(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to check ownership: %v", err)}[0],
		}, nil
	}
	if !owns {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{"Not authorized to remove this cassette from your collection"}[0],
		}, nil
	}

	err = r.HasuraClient.UnlinkCassetteFromUser(ctx, userInfo.UserID, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to delete cassette: %v", err)}[0],
		}, nil
	}

	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// RequestImageUploadURL is the resolver for the requestImageUploadURL field.
func (r *mutationResolver) RequestImageUploadURL(ctx context.Context, contentType string) (*model.ImageUploadURL, error) {
	// Require authentication
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	// Validate content type
	validTypes := map[string]bool{
		"image/jpeg": true,
		"image/png":  true,
		"image/webp": true,
	}
	if !validTypes[contentType] {
		return nil, fmt.Errorf("unsupported content type: %s (must be image/jpeg, image/png, or image/webp)", contentType)
	}

	if r.S3Service == nil {
		return nil, fmt.Errorf("image upload is not configured")
	}

	uploadURL, imageURL, err := r.S3Service.GenerateUploadURL(ctx, userInfo.UserID, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to generate upload URL: %w", err)
	}

	return &model.ImageUploadURL{
		UploadURL: uploadURL,
		ImageURL:  imageURL,
	}, nil
}

// MovieByTitle is the resolver for the movieByTitle field.
func (r *queryResolver) MovieByTitle(ctx context.Context, title string, director *string, year *int) (*model.MovieData, error) {
	return r.OMDBService.SearchMovie(ctx, title, director, year)
}

// MovieByBarcode is the resolver for the movieByBarcode field.
func (r *queryResolver) MovieByBarcode(ctx context.Context, barcode string) (*model.MovieData, error) {
	return r.BarcodeService.LookupMovie(ctx, barcode)
}

// Movie is the resolver for the movie field.
func (r *queryResolver) Movie(ctx context.Context, id string) (*model.Movie, error) {
	movieData, err := r.HasuraClient.GetMovieByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movie: %w", err)
	}
	if movieData == nil {
		return nil, nil
	}

	// Convert to model.Movie
	movie := &model.Movie{}
	if movieID, ok := movieData["id"].(string); ok {
		movie.ID = movieID
	}
	if title, ok := movieData["title"].(string); ok {
		movie.Title = title
	}
	if director, ok := movieData["director"].(string); ok {
		movie.Director = &director
	}
	if year, ok := movieData["year"].(float64); ok {
		yearInt := int(year)
		movie.Year = &yearInt
	}
	if genre, ok := movieData["genre"].(string); ok {
		movie.Genre = &genre
	}
	if coverURL, ok := movieData["cover_url"].(string); ok {
		movie.CoverURL = &coverURL
	}
	if createdAt, ok := movieData["created_at"].(string); ok {
		movie.CreatedAt = &createdAt
	}
	if updatedAt, ok := movieData["updated_at"].(string); ok {
		movie.UpdatedAt = &updatedAt
	}

	return movie, nil
}

// AlbumByArtistAndTitle is the resolver for the albumByArtistAndTitle field.
func (r *queryResolver) AlbumByArtistAndTitle(ctx context.Context, artist string, album string) (*model.AlbumData, error) {
	return r.MusicBrainz.SearchAlbum(ctx, artist, album)
}

// AlbumByBarcode is the resolver for the albumByBarcode field.
func (r *queryResolver) AlbumByBarcode(ctx context.Context, barcode string) (*model.AlbumData, error) {
	return r.BarcodeService.LookupAlbum(ctx, barcode)
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*model.Album, error) {
	albumData, err := r.HasuraClient.GetAlbumByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch album: %w", err)
	}
	if albumData == nil {
		return nil, nil
	}

	// Convert to model.Album
	album := &model.Album{}
	if albumID, ok := albumData["id"].(string); ok {
		album.ID = albumID
	}
	if artist, ok := albumData["artist"].(string); ok {
		album.Artist = artist
	}
	if albumName, ok := albumData["album"].(string); ok {
		album.Album = albumName
	}
	if year, ok := albumData["year"].(float64); ok {
		yearInt := int(year)
		album.Year = &yearInt
	}
	if label, ok := albumData["label"].(string); ok {
		album.Label = &label
	}
	if colorVariants, ok := albumData["color_variants"].([]interface{}); ok {
		variantStrs := make([]string, 0, len(colorVariants))
		for _, v := range colorVariants {
			if variantStr, ok := v.(string); ok {
				variantStrs = append(variantStrs, variantStr)
			}
		}
		if len(variantStrs) > 0 {
			album.ColorVariants = variantStrs
		}
	}
	if genres, ok := albumData["genres"].([]interface{}); ok {
		genreStrs := make([]string, 0, len(genres))
		for _, g := range genres {
			if genreStr, ok := g.(string); ok {
				genreStrs = append(genreStrs, genreStr)
			}
		}
		if len(genreStrs) > 0 {
			album.Genres = genreStrs
		}
	}
	if coverURL, ok := albumData["cover_url"].(string); ok {
		album.CoverURL = &coverURL
	}
	if size, ok := albumData["size"].(float64); ok {
		sizeInt := int(size)
		album.Size = &sizeInt
	}
	if createdAt, ok := albumData["created_at"].(string); ok {
		album.CreatedAt = &createdAt
	}
	if updatedAt, ok := albumData["updated_at"].(string); ok {
		album.UpdatedAt = &updatedAt
	}

	return album, nil
}

// CassetteByArtistAndTitle is the resolver for the cassetteByArtistAndTitle field.
func (r *queryResolver) CassetteByArtistAndTitle(ctx context.Context, artist string, album string) (*model.AlbumData, error) {
	return r.MusicBrainz.SearchAlbum(ctx, artist, album)
}

// CassetteByBarcode is the resolver for the cassetteByBarcode field.
func (r *queryResolver) CassetteByBarcode(ctx context.Context, barcode string) (*model.AlbumData, error) {
	return r.BarcodeService.LookupAlbum(ctx, barcode)
}

// Cassette is the resolver for the cassette field.
func (r *queryResolver) Cassette(ctx context.Context, id string) (*model.Cassette, error) {
	cassetteData, err := r.HasuraClient.GetCassetteByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch cassette: %w", err)
	}
	if cassetteData == nil {
		return nil, nil
	}

	cassette := &model.Cassette{}
	if cassetteID, ok := cassetteData["id"].(string); ok {
		cassette.ID = cassetteID
	}
	if artist, ok := cassetteData["artist"].(string); ok {
		cassette.Artist = artist
	}
	if albumName, ok := cassetteData["album"].(string); ok {
		cassette.Album = albumName
	}
	if year, ok := cassetteData["year"].(float64); ok {
		yearInt := int(year)
		cassette.Year = &yearInt
	}
	if label, ok := cassetteData["label"].(string); ok {
		cassette.Label = &label
	}
	if genres, ok := cassetteData["genres"].([]interface{}); ok {
		genreStrs := make([]string, 0, len(genres))
		for _, g := range genres {
			if genreStr, ok := g.(string); ok {
				genreStrs = append(genreStrs, genreStr)
			}
		}
		if len(genreStrs) > 0 {
			cassette.Genres = genreStrs
		}
	}
	if coverURL, ok := cassetteData["cover_url"].(string); ok {
		cassette.CoverURL = &coverURL
	}
	if tapeType, ok := cassetteData["tape_type"].(string); ok {
		cassette.TapeType = &tapeType
	}
	if createdAt, ok := cassetteData["created_at"].(string); ok {
		cassette.CreatedAt = &createdAt
	}
	if updatedAt, ok := cassetteData["updated_at"].(string); ok {
		cassette.UpdatedAt = &updatedAt
	}

	return cassette, nil
}

// Movies is the resolver for the movies field.
func (r *queryResolver) Movies(ctx context.Context) ([]*model.Movie, error) {
	// Fetch all movies from Hasura
	moviesData, err := r.HasuraClient.GetAllMovies(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movies: %w", err)
	}

	// Convert to model.Movie
	movies := make([]*model.Movie, 0, len(moviesData))
	for _, m := range moviesData {
		movie := &model.Movie{}

		// Required fields
		if id, ok := m["id"].(string); ok {
			movie.ID = id
		}
		if title, ok := m["title"].(string); ok {
			movie.Title = title
		}

		// Optional fields
		if director, ok := m["director"].(string); ok {
			movie.Director = &director
		}
		if year, ok := m["year"].(float64); ok {
			yearInt := int(year)
			movie.Year = &yearInt
		}
		if genre, ok := m["genre"].(string); ok {
			movie.Genre = &genre
		}
		if coverURL, ok := m["cover_url"].(string); ok {
			movie.CoverURL = &coverURL
		}
		if createdAt, ok := m["created_at"].(string); ok {
			movie.CreatedAt = &createdAt
		}
		if updatedAt, ok := m["updated_at"].(string); ok {
			movie.UpdatedAt = &updatedAt
		}

		movies = append(movies, movie)
	}

	fmt.Printf("[Movies] Fetched %d movies from Hasura\n", len(movies))
	return movies, nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context) ([]*model.Album, error) {
	// Fetch all albums from Hasura
	albumsData, err := r.HasuraClient.GetAllAlbums(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch albums: %w", err)
	}

	// Convert to model.Album
	albums := make([]*model.Album, 0, len(albumsData))
	for _, a := range albumsData {
		album := &model.Album{}

		// Required fields
		if id, ok := a["id"].(string); ok {
			album.ID = id
		}
		if artist, ok := a["artist"].(string); ok {
			album.Artist = artist
		}
		if albumName, ok := a["album"].(string); ok {
			album.Album = albumName
		}

		// Optional fields
		if year, ok := a["year"].(float64); ok {
			yearInt := int(year)
			album.Year = &yearInt
		}
		if label, ok := a["label"].(string); ok {
			album.Label = &label
		}
		if colorVariants, ok := a["color_variants"].([]interface{}); ok {
			variantStrs := make([]string, 0, len(colorVariants))
			for _, v := range colorVariants {
				if variantStr, ok := v.(string); ok {
					variantStrs = append(variantStrs, variantStr)
				}
			}
			if len(variantStrs) > 0 {
				album.ColorVariants = variantStrs
			}
		}
		if genres, ok := a["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				album.Genres = genreStrs
			}
		}
		if coverURL, ok := a["cover_url"].(string); ok {
			album.CoverURL = &coverURL
		}
		if size, ok := a["size"].(float64); ok {
			sizeInt := int(size)
			album.Size = &sizeInt
		}
		if createdAt, ok := a["created_at"].(string); ok {
			album.CreatedAt = &createdAt
		}
		if updatedAt, ok := a["updated_at"].(string); ok {
			album.UpdatedAt = &updatedAt
		}

		albums = append(albums, album)
	}

	fmt.Printf("[Albums] Fetched %d albums from Hasura\n", len(albums))
	return albums, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user from context
	userInfo, ok := custommw.GetUserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("not authenticated")
	}

	// Fetch full user details
	user, err := r.AuthService.GetUserByID(ctx, userInfo.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	return &model.User{
		ID:        user.ID,
		Email:     user.Email,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
		UpdatedAt: user.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Fetch user by ID
	user, err := r.AuthService.GetUserByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	if user == nil {
		return nil, nil
	}

	return &model.User{
		ID:        user.ID,
		Email:     user.Email,
		CreatedAt: user.CreatedAt.Format(time.RFC3339),
		UpdatedAt: user.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// UserMovies is the resolver for the userMovies field.
func (r *queryResolver) UserMovies(ctx context.Context, userID string) ([]*model.Movie, error) {
	// Fetch movies for the specified user
	moviesData, err := r.HasuraClient.GetMoviesByUserID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movies: %w", err)
	}

	// Convert to model.Movie
	movies := make([]*model.Movie, 0, len(moviesData))
	for _, m := range moviesData {
		movie := &model.Movie{}

		// Required fields
		if id, ok := m["id"].(string); ok {
			movie.ID = id
		}
		if title, ok := m["title"].(string); ok {
			movie.Title = title
		}

		// Optional fields
		if director, ok := m["director"].(string); ok {
			movie.Director = &director
		}
		if year, ok := m["year"].(float64); ok {
			yearInt := int(year)
			movie.Year = &yearInt
		}
		if genre, ok := m["genre"].(string); ok {
			movie.Genre = &genre
		}
		if coverURL, ok := m["cover_url"].(string); ok {
			movie.CoverURL = &coverURL
		}
		if createdAt, ok := m["created_at"].(string); ok {
			movie.CreatedAt = &createdAt
		}
		if updatedAt, ok := m["updated_at"].(string); ok {
			movie.UpdatedAt = &updatedAt
		}

		movies = append(movies, movie)
	}

	return movies, nil
}

// UserAlbums is the resolver for the userAlbums field.
func (r *queryResolver) UserAlbums(ctx context.Context, userID string) ([]*model.Album, error) {
	// Fetch albums for the specified user
	albumsData, err := r.HasuraClient.GetAlbumsByUserID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch albums: %w", err)
	}

	// Convert to model.Album
	albums := make([]*model.Album, 0, len(albumsData))
	for _, a := range albumsData {
		album := &model.Album{}

		// Required fields
		if id, ok := a["id"].(string); ok {
			album.ID = id
		}
		if artist, ok := a["artist"].(string); ok {
			album.Artist = artist
		}
		if albumName, ok := a["album"].(string); ok {
			album.Album = albumName
		}

		// Optional fields
		if year, ok := a["year"].(float64); ok {
			yearInt := int(year)
			album.Year = &yearInt
		}
		if label, ok := a["label"].(string); ok {
			album.Label = &label
		}
		if colorVariants, ok := a["color_variants"].([]interface{}); ok {
			variantStrs := make([]string, 0, len(colorVariants))
			for _, v := range colorVariants {
				if variantStr, ok := v.(string); ok {
					variantStrs = append(variantStrs, variantStr)
				}
			}
			if len(variantStrs) > 0 {
				album.ColorVariants = variantStrs
			}
		}
		if genres, ok := a["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				album.Genres = genreStrs
			}
		}
		if coverURL, ok := a["cover_url"].(string); ok {
			album.CoverURL = &coverURL
		}
		if size, ok := a["size"].(float64); ok {
			sizeInt := int(size)
			album.Size = &sizeInt
		}
		if createdAt, ok := a["created_at"].(string); ok {
			album.CreatedAt = &createdAt
		}
		if updatedAt, ok := a["updated_at"].(string); ok {
			album.UpdatedAt = &updatedAt
		}

		albums = append(albums, album)
	}

	return albums, nil
}

// UserCassettes is the resolver for the userCassettes field.
func (r *queryResolver) UserCassettes(ctx context.Context, userID string) ([]*model.Cassette, error) {
	cassettesData, err := r.HasuraClient.GetCassettesByUserID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch cassettes: %w", err)
	}

	cassettes := make([]*model.Cassette, 0, len(cassettesData))
	for _, c := range cassettesData {
		cassette := &model.Cassette{}

		if id, ok := c["id"].(string); ok {
			cassette.ID = id
		}
		if artist, ok := c["artist"].(string); ok {
			cassette.Artist = artist
		}
		if albumName, ok := c["album"].(string); ok {
			cassette.Album = albumName
		}
		if year, ok := c["year"].(float64); ok {
			yearInt := int(year)
			cassette.Year = &yearInt
		}
		if label, ok := c["label"].(string); ok {
			cassette.Label = &label
		}
		if genres, ok := c["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				cassette.Genres = genreStrs
			}
		}
		if coverURL, ok := c["cover_url"].(string); ok {
			cassette.CoverURL = &coverURL
		}
		if tapeType, ok := c["tape_type"].(string); ok {
			cassette.TapeType = &tapeType
		}
		if createdAt, ok := c["created_at"].(string); ok {
			cassette.CreatedAt = &createdAt
		}
		if updatedAt, ok := c["updated_at"].(string); ok {
			cassette.UpdatedAt = &updatedAt
		}

		cassettes = append(cassettes, cassette)
	}

	return cassettes, nil
}

// UserMoviesPaginated is the resolver for the userMoviesPaginated field.
func (r *queryResolver) UserMoviesPaginated(ctx context.Context, userID string, pagination *model.PaginationInput, sort *model.SortInput, search *string) (*model.MovieConnection, error) {
	// Default pagination values
	limit := 25
	offset := 0
	if pagination != nil {
		limit = pagination.Limit
		offset = pagination.Offset
	}

	// Default sort values
	sortField := "CREATED_AT"
	sortOrder := "DESC"
	if sort != nil {
		sortField = string(sort.Field)
		sortOrder = string(sort.Order)
	}

	// Fetch paginated movies from Hasura
	result, err := r.HasuraClient.GetMoviesByUserIDPaginated(ctx, userID, limit, offset, sortField, sortOrder, search)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movies: %w", err)
	}

	// Convert to model.Movie
	movies := make([]*model.Movie, 0, len(result.Items))
	for _, m := range result.Items {
		movie := &model.Movie{}

		if id, ok := m["id"].(string); ok {
			movie.ID = id
		}
		if title, ok := m["title"].(string); ok {
			movie.Title = title
		}
		if director, ok := m["director"].(string); ok {
			movie.Director = &director
		}
		if year, ok := m["year"].(float64); ok {
			yearInt := int(year)
			movie.Year = &yearInt
		}
		if genre, ok := m["genre"].(string); ok {
			movie.Genre = &genre
		}
		if coverURL, ok := m["cover_url"].(string); ok {
			movie.CoverURL = &coverURL
		}
		if createdAt, ok := m["created_at"].(string); ok {
			movie.CreatedAt = &createdAt
		}
		if updatedAt, ok := m["updated_at"].(string); ok {
			movie.UpdatedAt = &updatedAt
		}

		movies = append(movies, movie)
	}

	// Calculate hasNextPage
	hasNextPage := offset+len(movies) < result.TotalCount

	return &model.MovieConnection{
		Items: movies,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
			TotalCount:  result.TotalCount,
		},
	}, nil
}

// UserAlbumsPaginated is the resolver for the userAlbumsPaginated field.
func (r *queryResolver) UserAlbumsPaginated(ctx context.Context, userID string, pagination *model.PaginationInput, sort *model.SortInput, search *string) (*model.AlbumConnection, error) {
	// Default pagination values
	limit := 25
	offset := 0
	if pagination != nil {
		limit = pagination.Limit
		offset = pagination.Offset
	}

	// Default sort values
	sortField := "CREATED_AT"
	sortOrder := "DESC"
	if sort != nil {
		sortField = string(sort.Field)
		sortOrder = string(sort.Order)
	}

	// Fetch paginated albums from Hasura
	result, err := r.HasuraClient.GetAlbumsByUserIDPaginated(ctx, userID, limit, offset, sortField, sortOrder, search)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch albums: %w", err)
	}

	// Convert to model.Album
	albums := make([]*model.Album, 0, len(result.Items))
	for _, a := range result.Items {
		album := &model.Album{}

		if id, ok := a["id"].(string); ok {
			album.ID = id
		}
		if artist, ok := a["artist"].(string); ok {
			album.Artist = artist
		}
		if albumName, ok := a["album"].(string); ok {
			album.Album = albumName
		}
		if year, ok := a["year"].(float64); ok {
			yearInt := int(year)
			album.Year = &yearInt
		}
		if label, ok := a["label"].(string); ok {
			album.Label = &label
		}
		if colorVariants, ok := a["color_variants"].([]interface{}); ok {
			variantStrs := make([]string, 0, len(colorVariants))
			for _, v := range colorVariants {
				if variantStr, ok := v.(string); ok {
					variantStrs = append(variantStrs, variantStr)
				}
			}
			if len(variantStrs) > 0 {
				album.ColorVariants = variantStrs
			}
		}
		if genres, ok := a["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				album.Genres = genreStrs
			}
		}
		if coverURL, ok := a["cover_url"].(string); ok {
			album.CoverURL = &coverURL
		}
		if size, ok := a["size"].(float64); ok {
			sizeInt := int(size)
			album.Size = &sizeInt
		}
		if createdAt, ok := a["created_at"].(string); ok {
			album.CreatedAt = &createdAt
		}
		if updatedAt, ok := a["updated_at"].(string); ok {
			album.UpdatedAt = &updatedAt
		}

		albums = append(albums, album)
	}

	// Calculate hasNextPage
	hasNextPage := offset+len(albums) < result.TotalCount

	return &model.AlbumConnection{
		Items: albums,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
			TotalCount:  result.TotalCount,
		},
	}, nil
}

// UserCassettesPaginated is the resolver for the userCassettesPaginated field.
func (r *queryResolver) UserCassettesPaginated(ctx context.Context, userID string, pagination *model.PaginationInput, sort *model.SortInput, search *string) (*model.CassetteConnection, error) {
	limit := 25
	offset := 0
	if pagination != nil {
		limit = pagination.Limit
		offset = pagination.Offset
	}

	sortField := "CREATED_AT"
	sortOrder := "DESC"
	if sort != nil {
		sortField = string(sort.Field)
		sortOrder = string(sort.Order)
	}

	result, err := r.HasuraClient.GetCassettesByUserIDPaginated(ctx, userID, limit, offset, sortField, sortOrder, search)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch cassettes: %w", err)
	}

	cassettes := make([]*model.Cassette, 0, len(result.Items))
	for _, c := range result.Items {
		cassette := &model.Cassette{}

		if id, ok := c["id"].(string); ok {
			cassette.ID = id
		}
		if artist, ok := c["artist"].(string); ok {
			cassette.Artist = artist
		}
		if albumName, ok := c["album"].(string); ok {
			cassette.Album = albumName
		}
		if year, ok := c["year"].(float64); ok {
			yearInt := int(year)
			cassette.Year = &yearInt
		}
		if label, ok := c["label"].(string); ok {
			cassette.Label = &label
		}
		if genres, ok := c["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				cassette.Genres = genreStrs
			}
		}
		if coverURL, ok := c["cover_url"].(string); ok {
			cassette.CoverURL = &coverURL
		}
		if tapeType, ok := c["tape_type"].(string); ok {
			cassette.TapeType = &tapeType
		}
		if createdAt, ok := c["created_at"].(string); ok {
			cassette.CreatedAt = &createdAt
		}
		if updatedAt, ok := c["updated_at"].(string); ok {
			cassette.UpdatedAt = &updatedAt
		}

		cassettes = append(cassettes, cassette)
	}

	hasNextPage := offset+len(cassettes) < result.TotalCount

	return &model.CassetteConnection{
		Items: cassettes,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
			TotalCount:  result.TotalCount,
		},
	}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.Health, error) {
	uptime := int(time.Since(r.ServerStartTime).Seconds())
	return &model.Health{
		Status:  "ok",
		Version: "1.0.0",
		Uptime:  uptime,
	}, nil
}

// AppVersionConfig is the resolver for the appVersionConfig field.
func (r *queryResolver) AppVersionConfig(ctx context.Context) (*model.AppVersionConfig, error) {
	return &model.AppVersionConfig{
		MinimumIOSVersion: r.Config.MinimumIOSVersion,
		UpdateMessage:     r.Config.ForceUpdateMessage,
		ForceUpdate:       true,
		StoreURL:          r.Config.AppStoreURL,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
