package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"mediacloset/api/internal/graph/model"
	"time"
)

// SaveMovie is the resolver for the saveMovie field.
func (r *mutationResolver) SaveMovie(ctx context.Context, input model.SaveMovieInput) (*model.SaveMovieResponse, error) {
	// Validate required fields
	if input.Title == "" {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{"Title is required"}[0],
		}, nil
	}

	// Validate year if provided
	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveMovieResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch poster from OMDB
		movieData, err := r.OMDBService.SearchMovie(ctx, input.Title, input.Director, input.Year)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveMovie] Failed to fetch poster for '%s': %v\n", input.Title, err)
		} else if movieData != nil && movieData.PosterURL != nil {
			coverURL = *movieData.PosterURL
			fmt.Printf("[SaveMovie] Auto-fetched poster for '%s' from %s\n", input.Title, movieData.Source)
		} else {
			fmt.Printf("[SaveMovie] No poster found for '%s'\n", input.Title)
		}
	}

	// Build VHS object for Hasura
	vhs := map[string]interface{}{
		"title": input.Title,
	}

	if input.Director != nil {
		vhs["director"] = *input.Director
	}
	if input.Year != nil {
		vhs["year"] = *input.Year
	}
	if input.Genre != nil {
		vhs["genre"] = *input.Genre
	}
	if coverURL != "" {
		vhs["cover_url"] = coverURL
	}

	// Save to Hasura
	_, err := r.HasuraClient.InsertVHS(ctx, vhs)
	if err != nil {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to save movie: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveMovieResponse{
		Success: true,
		Movie: &model.SavedMovie{
			ID:       0, // ID not returned by Hasura
			Title:    input.Title,
			Director: input.Director,
			Year:     input.Year,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// SaveAlbum is the resolver for the saveAlbum field.
func (r *mutationResolver) SaveAlbum(ctx context.Context, input model.SaveAlbumInput) (*model.SaveAlbumResponse, error) {
	// Validate required fields
	if input.Artist == "" {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Artist is required"}[0],
		}, nil
	}
	if input.Album == "" {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Album is required"}[0],
		}, nil
	}

	// Validate year if provided
	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveAlbumResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch cover art from MusicBrainz
		albumData, err := r.MusicBrainz.SearchAlbum(ctx, input.Artist, input.Album)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveAlbum] Failed to fetch cover for '%s - %s': %v\n", input.Artist, input.Album, err)
		} else if albumData != nil && albumData.CoverURL != nil {
			coverURL = *albumData.CoverURL
			fmt.Printf("[SaveAlbum] Auto-fetched cover for '%s - %s' from %s\n", input.Artist, input.Album, albumData.Source)
		} else {
			fmt.Printf("[SaveAlbum] No cover found for '%s - %s'\n", input.Artist, input.Album)
		}
	}

	// Build record object for Hasura
	record := map[string]interface{}{
		"artist": input.Artist,
		"album":  input.Album,
	}

	if input.Year != nil {
		record["year"] = *input.Year
	}
	if input.Label != nil {
		record["label"] = *input.Label
	}
	if input.Genre != nil {
		record["genres"] = []string{*input.Genre}
	}
	if coverURL != "" {
		record["cover_url"] = coverURL
	}

	// Save to Hasura
	_, err := r.HasuraClient.InsertRecord(ctx, record)
	if err != nil {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to save album: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveAlbumResponse{
		Success: true,
		Album: &model.SavedAlbum{
			ID:       0, // ID not returned by Hasura
			Artist:   input.Artist,
			Album:    input.Album,
			Year:     input.Year,
			Label:    input.Label,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// MovieByTitle is the resolver for the movieByTitle field.
func (r *queryResolver) MovieByTitle(ctx context.Context, title string, director *string, year *int) (*model.MovieData, error) {
	return r.OMDBService.SearchMovie(ctx, title, director, year)
}

// MovieByBarcode is the resolver for the movieByBarcode field.
func (r *queryResolver) MovieByBarcode(ctx context.Context, barcode string) (*model.MovieData, error) {
	return r.BarcodeService.LookupMovie(ctx, barcode)
}

// AlbumByArtistAndTitle is the resolver for the albumByArtistAndTitle field.
func (r *queryResolver) AlbumByArtistAndTitle(ctx context.Context, artist string, album string) (*model.AlbumData, error) {
	return r.MusicBrainz.SearchAlbum(ctx, artist, album)
}

// AlbumByBarcode is the resolver for the albumByBarcode field.
func (r *queryResolver) AlbumByBarcode(ctx context.Context, barcode string) (*model.AlbumData, error) {
	return r.BarcodeService.LookupAlbum(ctx, barcode)
}

// Movies is the resolver for the movies field.
func (r *queryResolver) Movies(ctx context.Context) ([]*model.Movie, error) {
	// Fetch all movies from Hasura
	moviesData, err := r.HasuraClient.GetAllMovies(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movies: %w", err)
	}

	// Convert to model.Movie
	movies := make([]*model.Movie, 0, len(moviesData))
	for _, m := range moviesData {
		movie := &model.Movie{}

		// Required fields
		if id, ok := m["id"].(string); ok {
			movie.ID = id
		}
		if title, ok := m["title"].(string); ok {
			movie.Title = title
		}

		// Optional fields
		if director, ok := m["director"].(string); ok {
			movie.Director = &director
		}
		if year, ok := m["year"].(float64); ok {
			yearInt := int(year)
			movie.Year = &yearInt
		}
		if genre, ok := m["genre"].(string); ok {
			movie.Genre = &genre
		}
		if coverURL, ok := m["cover_url"].(string); ok {
			movie.CoverURL = &coverURL
		}
		if createdAt, ok := m["created_at"].(string); ok {
			movie.CreatedAt = &createdAt
		}
		if updatedAt, ok := m["updated_at"].(string); ok {
			movie.UpdatedAt = &updatedAt
		}

		movies = append(movies, movie)
	}

	fmt.Printf("[Movies] Fetched %d movies from Hasura\n", len(movies))
	return movies, nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context) ([]*model.Album, error) {
	// Fetch all albums from Hasura
	albumsData, err := r.HasuraClient.GetAllAlbums(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch albums: %w", err)
	}

	// Convert to model.Album
	albums := make([]*model.Album, 0, len(albumsData))
	for _, a := range albumsData {
		album := &model.Album{}

		// Required fields
		if id, ok := a["id"].(string); ok {
			album.ID = id
		}
		if artist, ok := a["artist"].(string); ok {
			album.Artist = artist
		}
		if albumName, ok := a["album"].(string); ok {
			album.Album = albumName
		}

		// Optional fields
		if year, ok := a["year"].(float64); ok {
			yearInt := int(year)
			album.Year = &yearInt
		}
		if label, ok := a["label"].(string); ok {
			album.Label = &label
		}
		if genres, ok := a["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				album.Genres = genreStrs
			}
		}
		if coverURL, ok := a["cover_url"].(string); ok {
			album.CoverURL = &coverURL
		}
		if createdAt, ok := a["created_at"].(string); ok {
			album.CreatedAt = &createdAt
		}
		if updatedAt, ok := a["updated_at"].(string); ok {
			album.UpdatedAt = &updatedAt
		}

		albums = append(albums, album)
	}

	fmt.Printf("[Albums] Fetched %d albums from Hasura\n", len(albums))
	return albums, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.Health, error) {
	uptime := int(time.Since(r.ServerStartTime).Seconds())
	return &model.Health{
		Status:  "ok",
		Version: "1.0.0",
		Uptime:  uptime,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
