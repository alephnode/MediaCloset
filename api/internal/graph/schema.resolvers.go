package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"mediacloset/api/internal/graph/model"
	"time"
)

// SaveMovie is the resolver for the saveMovie field.
func (r *mutationResolver) SaveMovie(ctx context.Context, input model.SaveMovieInput) (*model.SaveMovieResponse, error) {
	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch poster from OMDB
		movieData, err := r.OMDBService.SearchMovie(ctx, input.Title, input.Director, input.Year)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveMovie] Failed to fetch poster for '%s': %v\n", input.Title, err)
		} else if movieData != nil && movieData.PosterURL != nil {
			coverURL = *movieData.PosterURL
			fmt.Printf("[SaveMovie] Auto-fetched poster for '%s' from %s\n", input.Title, movieData.Source)
		} else {
			fmt.Printf("[SaveMovie] No poster found for '%s'\n", input.Title)
		}
	}

	// Build VHS object for Hasura
	vhs := map[string]interface{}{
		"title": input.Title,
	}

	if input.Director != nil {
		vhs["director"] = *input.Director
	}
	if input.Year != nil {
		vhs["year"] = *input.Year
	}
	if input.Genre != nil {
		vhs["genre"] = *input.Genre
	}
	if coverURL != "" {
		vhs["cover_url"] = coverURL
	}

	// Save to Hasura
	_, err := r.HasuraClient.InsertVHS(ctx, vhs)
	if err != nil {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to save movie: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveMovieResponse{
		Success: true,
		Movie: &model.SavedMovie{
			ID:       0, // ID not returned by Hasura
			Title:    input.Title,
			Director: input.Director,
			Year:     input.Year,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// SaveAlbum is the resolver for the saveAlbum field.
func (r *mutationResolver) SaveAlbum(ctx context.Context, input model.SaveAlbumInput) (*model.SaveAlbumResponse, error) {
	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch cover art from MusicBrainz
		albumData, err := r.MusicBrainz.SearchAlbum(ctx, input.Artist, input.Album)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveAlbum] Failed to fetch cover for '%s - %s': %v\n", input.Artist, input.Album, err)
		} else if albumData != nil && albumData.CoverURL != nil {
			coverURL = *albumData.CoverURL
			fmt.Printf("[SaveAlbum] Auto-fetched cover for '%s - %s' from %s\n", input.Artist, input.Album, albumData.Source)
		} else {
			fmt.Printf("[SaveAlbum] No cover found for '%s - %s'\n", input.Artist, input.Album)
		}
	}

	// Build record object for Hasura
	record := map[string]interface{}{
		"artist": input.Artist,
		"album":  input.Album,
	}

	if input.Year != nil {
		record["year"] = *input.Year
	}
	if input.Label != nil {
		record["label"] = *input.Label
	}
	if input.Genre != nil {
		record["genres"] = []string{*input.Genre}
	}
	if coverURL != "" {
		record["cover_url"] = coverURL
	}

	// Save to Hasura
	_, err := r.HasuraClient.InsertRecord(ctx, record)
	if err != nil {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to save album: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveAlbumResponse{
		Success: true,
		Album: &model.SavedAlbum{
			ID:       0, // ID not returned by Hasura
			Artist:   input.Artist,
			Album:    input.Album,
			Year:     input.Year,
			Label:    input.Label,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// MovieByTitle is the resolver for the movieByTitle field.
func (r *queryResolver) MovieByTitle(ctx context.Context, title string, director *string, year *int) (*model.MovieData, error) {
	return r.OMDBService.SearchMovie(ctx, title, director, year)
}

// MovieByBarcode is the resolver for the movieByBarcode field.
func (r *queryResolver) MovieByBarcode(ctx context.Context, barcode string) (*model.MovieData, error) {
	return r.BarcodeService.LookupMovie(ctx, barcode)
}

// AlbumByArtistAndTitle is the resolver for the albumByArtistAndTitle field.
func (r *queryResolver) AlbumByArtistAndTitle(ctx context.Context, artist string, album string) (*model.AlbumData, error) {
	return r.MusicBrainz.SearchAlbum(ctx, artist, album)
}

// AlbumByBarcode is the resolver for the albumByBarcode field.
func (r *queryResolver) AlbumByBarcode(ctx context.Context, barcode string) (*model.AlbumData, error) {
	return r.BarcodeService.LookupAlbum(ctx, barcode)
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.Health, error) {
	uptime := int(time.Since(r.ServerStartTime).Seconds())
	return &model.Health{
		Status:  "ok",
		Version: "1.0.0",
		Uptime:  uptime,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
