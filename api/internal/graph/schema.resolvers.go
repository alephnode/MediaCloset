package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"mediacloset/api/internal/graph/model"
	"time"
)

// SaveMovie is the resolver for the saveMovie field.
func (r *mutationResolver) SaveMovie(ctx context.Context, input model.SaveMovieInput) (*model.SaveMovieResponse, error) {
	// Validate required fields
	if input.Title == "" {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{"Title is required"}[0],
		}, nil
	}

	// Validate year if provided
	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveMovieResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch poster from OMDB
		movieData, err := r.OMDBService.SearchMovie(ctx, input.Title, input.Director, input.Year)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveMovie] Failed to fetch poster for '%s': %v\n", input.Title, err)
		} else if movieData != nil && movieData.PosterURL != nil {
			coverURL = *movieData.PosterURL
			fmt.Printf("[SaveMovie] Auto-fetched poster for '%s' from %s\n", input.Title, movieData.Source)
		} else {
			fmt.Printf("[SaveMovie] No poster found for '%s'\n", input.Title)
		}
	}

	// Build VHS object for Hasura
	vhs := map[string]interface{}{
		"title": input.Title,
	}

	if input.Director != nil {
		vhs["director"] = *input.Director
	}
	if input.Year != nil {
		vhs["year"] = *input.Year
	}
	if input.Genre != nil {
		vhs["genre"] = *input.Genre
	}
	if coverURL != "" {
		vhs["cover_url"] = coverURL
	}

	// Save to Hasura
	_, err := r.HasuraClient.InsertVHS(ctx, vhs)
	if err != nil {
		return &model.SaveMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to save movie: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveMovieResponse{
		Success: true,
		Movie: &model.SavedMovie{
			ID:       0, // ID not returned by Hasura
			Title:    input.Title,
			Director: input.Director,
			Year:     input.Year,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// UpdateMovie is the resolver for the updateMovie field.
func (r *mutationResolver) UpdateMovie(ctx context.Context, id string, input model.UpdateMovieInput) (*model.UpdateMovieResponse, error) {
	// Build updates map
	updates := make(map[string]interface{})

	if input.Title != nil {
		updates["title"] = *input.Title
	}
	if input.Director != nil {
		updates["director"] = *input.Director
	}
	if input.Year != nil {
		updates["year"] = *input.Year
	}
	if input.Genre != nil {
		updates["genre"] = *input.Genre
	}
	if input.CoverURL != nil {
		updates["cover_url"] = *input.CoverURL
	}

	// Update in Hasura
	movieData, err := r.HasuraClient.UpdateMovie(ctx, id, updates)
	if err != nil {
		return &model.UpdateMovieResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to update movie: %v", err)}[0],
		}, nil
	}

	// Convert to model.Movie
	movie := &model.Movie{}
	if movieID, ok := movieData["id"].(string); ok {
		movie.ID = movieID
	}
	if title, ok := movieData["title"].(string); ok {
		movie.Title = title
	}
	if director, ok := movieData["director"].(string); ok {
		movie.Director = &director
	}
	if year, ok := movieData["year"].(float64); ok {
		yearInt := int(year)
		movie.Year = &yearInt
	}
	if genre, ok := movieData["genre"].(string); ok {
		movie.Genre = &genre
	}
	if coverURL, ok := movieData["cover_url"].(string); ok {
		movie.CoverURL = &coverURL
	}
	if createdAt, ok := movieData["created_at"].(string); ok {
		movie.CreatedAt = &createdAt
	}
	if updatedAt, ok := movieData["updated_at"].(string); ok {
		movie.UpdatedAt = &updatedAt
	}

	return &model.UpdateMovieResponse{
		Success: true,
		Movie:   movie,
	}, nil
}

// DeleteMovie is the resolver for the deleteMovie field.
func (r *mutationResolver) DeleteMovie(ctx context.Context, id string) (*model.DeleteResponse, error) {
	err := r.HasuraClient.DeleteMovie(ctx, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to delete movie: %v", err)}[0],
		}, nil
	}

	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// SaveAlbum is the resolver for the saveAlbum field.
func (r *mutationResolver) SaveAlbum(ctx context.Context, input model.SaveAlbumInput) (*model.SaveAlbumResponse, error) {
	// Validate required fields
	if input.Artist == "" {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Artist is required"}[0],
		}, nil
	}
	if input.Album == "" {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{"Album is required"}[0],
		}, nil
	}

	// Validate year if provided
	if input.Year != nil {
		year := *input.Year
		if year < 1800 || year > 2100 {
			return &model.SaveAlbumResponse{
				Success: false,
				Error:   &[]string{"Year must be between 1800 and 2100"}[0],
			}, nil
		}
	}

	// Get cover URL if not provided
	coverURL := ""
	if input.CoverURL != nil && *input.CoverURL != "" {
		coverURL = *input.CoverURL
	} else {
		// Auto-fetch cover art from MusicBrainz
		albumData, err := r.MusicBrainz.SearchAlbum(ctx, input.Artist, input.Album)
		if err != nil {
			// Log the error but don't fail the save
			fmt.Printf("[SaveAlbum] Failed to fetch cover for '%s - %s': %v\n", input.Artist, input.Album, err)
		} else if albumData != nil && albumData.CoverURL != nil {
			coverURL = *albumData.CoverURL
			fmt.Printf("[SaveAlbum] Auto-fetched cover for '%s - %s' from %s\n", input.Artist, input.Album, albumData.Source)
		} else {
			fmt.Printf("[SaveAlbum] No cover found for '%s - %s'\n", input.Artist, input.Album)
		}
	}

	// Build record object for Hasura
	record := map[string]interface{}{
		"artist": input.Artist,
		"album":  input.Album,
	}

	if input.Year != nil {
		record["year"] = *input.Year
	}
	if input.Label != nil {
		record["label"] = *input.Label
	}
	if input.Genre != nil {
		record["genres"] = []string{*input.Genre}
	}
	if coverURL != "" {
		record["cover_url"] = coverURL
	}

	// Save to Hasura
	_, err := r.HasuraClient.InsertRecord(ctx, record)
	if err != nil {
		return &model.SaveAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to save album: %v", err)}[0],
		}, nil
	}

	// Return success response
	// Note: Hasura returns UUID, but we're not using it in the response for now
	return &model.SaveAlbumResponse{
		Success: true,
		Album: &model.SavedAlbum{
			ID:       0, // ID not returned by Hasura
			Artist:   input.Artist,
			Album:    input.Album,
			Year:     input.Year,
			Label:    input.Label,
			Genre:    input.Genre,
			CoverURL: &coverURL,
		},
	}, nil
}

// UpdateAlbum is the resolver for the updateAlbum field.
func (r *mutationResolver) UpdateAlbum(ctx context.Context, id string, input model.UpdateAlbumInput) (*model.UpdateAlbumResponse, error) {
	// Build updates map
	updates := make(map[string]interface{})

	if input.Artist != nil {
		updates["artist"] = *input.Artist
	}
	if input.Album != nil {
		updates["album"] = *input.Album
	}
	if input.Year != nil {
		updates["year"] = *input.Year
	}
	if input.Label != nil {
		updates["label"] = *input.Label
	}
	if input.Genre != nil {
		updates["genre"] = *input.Genre
	}
	if input.CoverURL != nil {
		updates["cover_url"] = *input.CoverURL
	}

	// Update in Hasura
	albumData, err := r.HasuraClient.UpdateAlbum(ctx, id, updates)
	if err != nil {
		return &model.UpdateAlbumResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to update album: %v", err)}[0],
		}, nil
	}

	// Convert to model.Album
	album := &model.Album{}
	if albumID, ok := albumData["id"].(string); ok {
		album.ID = albumID
	}
	if artist, ok := albumData["artist"].(string); ok {
		album.Artist = artist
	}
	if albumName, ok := albumData["album"].(string); ok {
		album.Album = albumName
	}
	if year, ok := albumData["year"].(float64); ok {
		yearInt := int(year)
		album.Year = &yearInt
	}
	if label, ok := albumData["label"].(string); ok {
		album.Label = &label
	}
	if colorVariant, ok := albumData["color_variant"].(string); ok {
		album.ColorVariant = &colorVariant
	}
	if genres, ok := albumData["genres"].([]interface{}); ok {
		genreStrs := make([]string, 0, len(genres))
		for _, g := range genres {
			if genreStr, ok := g.(string); ok {
				genreStrs = append(genreStrs, genreStr)
			}
		}
		if len(genreStrs) > 0 {
			album.Genres = genreStrs
		}
	}
	if coverURL, ok := albumData["cover_url"].(string); ok {
		album.CoverURL = &coverURL
	}
	if createdAt, ok := albumData["created_at"].(string); ok {
		album.CreatedAt = &createdAt
	}
	if updatedAt, ok := albumData["updated_at"].(string); ok {
		album.UpdatedAt = &updatedAt
	}

	return &model.UpdateAlbumResponse{
		Success: true,
		Album:   album,
	}, nil
}

// DeleteAlbum is the resolver for the deleteAlbum field.
func (r *mutationResolver) DeleteAlbum(ctx context.Context, id string) (*model.DeleteResponse, error) {
	err := r.HasuraClient.DeleteAlbum(ctx, id)
	if err != nil {
		return &model.DeleteResponse{
			Success: false,
			Error:   &[]string{fmt.Sprintf("Failed to delete album: %v", err)}[0],
		}, nil
	}

	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// MovieByTitle is the resolver for the movieByTitle field.
func (r *queryResolver) MovieByTitle(ctx context.Context, title string, director *string, year *int) (*model.MovieData, error) {
	return r.OMDBService.SearchMovie(ctx, title, director, year)
}

// MovieByBarcode is the resolver for the movieByBarcode field.
func (r *queryResolver) MovieByBarcode(ctx context.Context, barcode string) (*model.MovieData, error) {
	return r.BarcodeService.LookupMovie(ctx, barcode)
}

// Movie is the resolver for the movie field.
func (r *queryResolver) Movie(ctx context.Context, id string) (*model.Movie, error) {
	movieData, err := r.HasuraClient.GetMovieByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movie: %w", err)
	}
	if movieData == nil {
		return nil, nil
	}

	// Convert to model.Movie
	movie := &model.Movie{}
	if movieID, ok := movieData["id"].(string); ok {
		movie.ID = movieID
	}
	if title, ok := movieData["title"].(string); ok {
		movie.Title = title
	}
	if director, ok := movieData["director"].(string); ok {
		movie.Director = &director
	}
	if year, ok := movieData["year"].(float64); ok {
		yearInt := int(year)
		movie.Year = &yearInt
	}
	if genre, ok := movieData["genre"].(string); ok {
		movie.Genre = &genre
	}
	if coverURL, ok := movieData["cover_url"].(string); ok {
		movie.CoverURL = &coverURL
	}
	if createdAt, ok := movieData["created_at"].(string); ok {
		movie.CreatedAt = &createdAt
	}
	if updatedAt, ok := movieData["updated_at"].(string); ok {
		movie.UpdatedAt = &updatedAt
	}

	return movie, nil
}

// AlbumByArtistAndTitle is the resolver for the albumByArtistAndTitle field.
func (r *queryResolver) AlbumByArtistAndTitle(ctx context.Context, artist string, album string) (*model.AlbumData, error) {
	return r.MusicBrainz.SearchAlbum(ctx, artist, album)
}

// AlbumByBarcode is the resolver for the albumByBarcode field.
func (r *queryResolver) AlbumByBarcode(ctx context.Context, barcode string) (*model.AlbumData, error) {
	return r.BarcodeService.LookupAlbum(ctx, barcode)
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*model.Album, error) {
	albumData, err := r.HasuraClient.GetAlbumByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch album: %w", err)
	}
	if albumData == nil {
		return nil, nil
	}

	// Convert to model.Album
	album := &model.Album{}
	if albumID, ok := albumData["id"].(string); ok {
		album.ID = albumID
	}
	if artist, ok := albumData["artist"].(string); ok {
		album.Artist = artist
	}
	if albumName, ok := albumData["album"].(string); ok {
		album.Album = albumName
	}
	if year, ok := albumData["year"].(float64); ok {
		yearInt := int(year)
		album.Year = &yearInt
	}
	if label, ok := albumData["label"].(string); ok {
		album.Label = &label
	}
	if colorVariant, ok := albumData["color_variant"].(string); ok {
		album.ColorVariant = &colorVariant
	}
	if genres, ok := albumData["genres"].([]interface{}); ok {
		genreStrs := make([]string, 0, len(genres))
		for _, g := range genres {
			if genreStr, ok := g.(string); ok {
				genreStrs = append(genreStrs, genreStr)
			}
		}
		if len(genreStrs) > 0 {
			album.Genres = genreStrs
		}
	}
	if coverURL, ok := albumData["cover_url"].(string); ok {
		album.CoverURL = &coverURL
	}
	if createdAt, ok := albumData["created_at"].(string); ok {
		album.CreatedAt = &createdAt
	}
	if updatedAt, ok := albumData["updated_at"].(string); ok {
		album.UpdatedAt = &updatedAt
	}

	return album, nil
}

// Movies is the resolver for the movies field.
func (r *queryResolver) Movies(ctx context.Context) ([]*model.Movie, error) {
	// Fetch all movies from Hasura
	moviesData, err := r.HasuraClient.GetAllMovies(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movies: %w", err)
	}

	// Convert to model.Movie
	movies := make([]*model.Movie, 0, len(moviesData))
	for _, m := range moviesData {
		movie := &model.Movie{}

		// Required fields
		if id, ok := m["id"].(string); ok {
			movie.ID = id
		}
		if title, ok := m["title"].(string); ok {
			movie.Title = title
		}

		// Optional fields
		if director, ok := m["director"].(string); ok {
			movie.Director = &director
		}
		if year, ok := m["year"].(float64); ok {
			yearInt := int(year)
			movie.Year = &yearInt
		}
		if genre, ok := m["genre"].(string); ok {
			movie.Genre = &genre
		}
		if coverURL, ok := m["cover_url"].(string); ok {
			movie.CoverURL = &coverURL
		}
		if createdAt, ok := m["created_at"].(string); ok {
			movie.CreatedAt = &createdAt
		}
		if updatedAt, ok := m["updated_at"].(string); ok {
			movie.UpdatedAt = &updatedAt
		}

		movies = append(movies, movie)
	}

	fmt.Printf("[Movies] Fetched %d movies from Hasura\n", len(movies))
	return movies, nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context) ([]*model.Album, error) {
	// Fetch all albums from Hasura
	albumsData, err := r.HasuraClient.GetAllAlbums(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch albums: %w", err)
	}

	// Convert to model.Album
	albums := make([]*model.Album, 0, len(albumsData))
	for _, a := range albumsData {
		album := &model.Album{}

		// Required fields
		if id, ok := a["id"].(string); ok {
			album.ID = id
		}
		if artist, ok := a["artist"].(string); ok {
			album.Artist = artist
		}
		if albumName, ok := a["album"].(string); ok {
			album.Album = albumName
		}

		// Optional fields
		if year, ok := a["year"].(float64); ok {
			yearInt := int(year)
			album.Year = &yearInt
		}
		if label, ok := a["label"].(string); ok {
			album.Label = &label
		}
		if colorVariant, ok := a["color_variant"].(string); ok {
			album.ColorVariant = &colorVariant
		}
		if genres, ok := a["genres"].([]interface{}); ok {
			genreStrs := make([]string, 0, len(genres))
			for _, g := range genres {
				if genreStr, ok := g.(string); ok {
					genreStrs = append(genreStrs, genreStr)
				}
			}
			if len(genreStrs) > 0 {
				album.Genres = genreStrs
			}
		}
		if coverURL, ok := a["cover_url"].(string); ok {
			album.CoverURL = &coverURL
		}
		if createdAt, ok := a["created_at"].(string); ok {
			album.CreatedAt = &createdAt
		}
		if updatedAt, ok := a["updated_at"].(string); ok {
			album.UpdatedAt = &updatedAt
		}

		albums = append(albums, album)
	}

	fmt.Printf("[Albums] Fetched %d albums from Hasura\n", len(albums))
	return albums, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.Health, error) {
	uptime := int(time.Since(r.ServerStartTime).Seconds())
	return &model.Health{
		Status:  "ok",
		Version: "1.0.0",
		Uptime:  uptime,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
