# MediaCloset GraphQL Schema
# Proxies external APIs (OMDB, MusicBrainz, Discogs, iTunes, UPC Database)

type Query {
  # Movie/VHS lookups
  movieByTitle(title: String!, director: String, year: Int): MovieData
  movieByBarcode(barcode: String!): MovieData
  movie(id: String!): Movie  # Get movie by ID

  # Album/Record lookups
  albumByArtistAndTitle(artist: String!, album: String!): AlbumData
  albumByBarcode(barcode: String!): AlbumData
  album(id: String!): Album  # Get album by ID

  # List all movies/albums from database
  movies: [Movie!]!
  albums: [Album!]!

  # Health check
  health: Health!
}

type Mutation {
  # Save movie/VHS (auto-fetches poster if missing)
  saveMovie(input: SaveMovieInput!): SaveMovieResponse!

  # Update existing movie/VHS
  updateMovie(id: String!, input: UpdateMovieInput!): UpdateMovieResponse!

  # Delete movie/VHS
  deleteMovie(id: String!): DeleteResponse!

  # Save album/record (auto-fetches cover if missing)
  saveAlbum(input: SaveAlbumInput!): SaveAlbumResponse!

  # Update existing album/record
  updateAlbum(id: String!, input: UpdateAlbumInput!): UpdateAlbumResponse!

  # Delete album/record
  deleteAlbum(id: String!): DeleteResponse!
}

type MovieData {
  title: String!
  director: String
  year: Int
  genre: String
  posterUrl: String
  plot: String
  source: String!  # "omdb", "upc_database"
}

type AlbumData {
  artist: String
  album: String
  year: Int
  label: String
  genres: [String!]
  coverUrl: String
  tracks: [TrackData!]
  source: String!  # "discogs", "musicbrainz", "itunes"
}

type TrackData {
  title: String!
  trackNumber: Int
  durationSeconds: Int
}

type Health {
  status: String!
  version: String!
  uptime: Int!
}

# Input types for mutations
input SaveMovieInput {
  title: String!
  director: String
  year: Int
  genre: String
  coverUrl: String  # Optional - will be auto-fetched if missing
}

input UpdateMovieInput {
  title: String
  director: String
  year: Int
  genre: String
  coverUrl: String
}

input SaveAlbumInput {
  artist: String!
  album: String!
  year: Int
  label: String
  genre: String
  coverUrl: String  # Optional - will be auto-fetched if missing
}

input UpdateAlbumInput {
  artist: String
  album: String
  year: Int
  label: String
  genre: String
  coverUrl: String
}

# Response types for mutations
type SaveMovieResponse {
  success: Boolean!
  id: Int
  movie: SavedMovie
  error: String
}

type UpdateMovieResponse {
  success: Boolean!
  movie: Movie
  error: String
}

type SaveAlbumResponse {
  success: Boolean!
  id: Int
  album: SavedAlbum
  error: String
}

type UpdateAlbumResponse {
  success: Boolean!
  album: Album
  error: String
}

type DeleteResponse {
  success: Boolean!
  error: String
}

# Saved data types (from Hasura)
type SavedMovie {
  id: Int!
  title: String!
  director: String
  year: Int
  genre: String
  coverUrl: String
}

type SavedAlbum {
  id: Int!
  artist: String!
  album: String!
  year: Int
  label: String
  genre: String
  coverUrl: String
}

# Database list types (from Hasura queries)
type Movie {
  id: String!  # UUID from Hasura
  title: String!
  director: String
  year: Int
  genre: String
  coverUrl: String
  createdAt: String
  updatedAt: String
}

type Album {
  id: String!  # UUID from Hasura
  artist: String!
  album: String!
  year: Int
  label: String
  color_variant: String
  genres: [String!]
  coverUrl: String
  createdAt: String
  updatedAt: String
}
