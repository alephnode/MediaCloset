# MediaCloset GraphQL Schema
# Proxies external APIs (OMDB, MusicBrainz, Discogs, iTunes, UPC Database)

# Pagination and sorting inputs
input PaginationInput {
  limit: Int! = 25
  offset: Int! = 0
}

enum SortField {
  CREATED_AT
  TITLE
  ARTIST
  YEAR
}

enum SortOrder {
  ASC
  DESC
}

input SortInput {
  field: SortField!
  order: SortOrder! = DESC
}

# Pagination response types
type PageInfo {
  hasNextPage: Boolean!
  totalCount: Int!
}

type MovieConnection {
  items: [Movie!]!
  pageInfo: PageInfo!
}

type AlbumConnection {
  items: [Album!]!
  pageInfo: PageInfo!
}

type Query {
  # Movie/VHS lookups
  movieByTitle(title: String!, director: String, year: Int): MovieData
  movieByBarcode(barcode: String!): MovieData
  movie(id: String!): Movie  # Get movie by ID

  # Album/Record lookups
  albumByArtistAndTitle(artist: String!, album: String!): AlbumData
  albumByBarcode(barcode: String!): AlbumData
  album(id: String!): Album  # Get album by ID

  # List all movies/albums from database (filtered by authenticated user)
  # Legacy non-paginated queries (deprecated - use paginated versions)
  movies: [Movie!]! @deprecated(reason: "Use userMoviesPaginated instead")
  albums: [Album!]! @deprecated(reason: "Use userAlbumsPaginated instead")

  # User info
  me: User  # Get current authenticated user
  user(id: String!): User  # Get user by ID

  # Get movies/albums for a specific user (legacy)
  userMovies(userId: String!): [Movie!]! @deprecated(reason: "Use userMoviesPaginated instead")
  userAlbums(userId: String!): [Album!]! @deprecated(reason: "Use userAlbumsPaginated instead")

  # Paginated queries with search, sort, and filtering
  userMoviesPaginated(
    userId: String!
    pagination: PaginationInput
    sort: SortInput
    search: String
  ): MovieConnection!

  userAlbumsPaginated(
    userId: String!
    pagination: PaginationInput
    sort: SortInput
    search: String
  ): AlbumConnection!

  # Health check
  health: Health!
}

type Mutation {
  # Authentication
  requestLoginCode(email: String!): RequestLoginCodeResponse!
  verifyLoginCode(email: String!, code: String!): VerifyLoginCodeResponse!

  # Save movie/VHS (auto-fetches poster if missing)
  saveMovie(input: SaveMovieInput!): SaveMovieResponse!

  # Update existing movie/VHS
  updateMovie(id: String!, input: UpdateMovieInput!): UpdateMovieResponse!

  # Delete movie/VHS
  deleteMovie(id: String!): DeleteResponse!

  # Save album/record (auto-fetches cover if missing)
  saveAlbum(input: SaveAlbumInput!): SaveAlbumResponse!

  # Update existing album/record
  updateAlbum(id: String!, input: UpdateAlbumInput!): UpdateAlbumResponse!

  # Delete album/record
  deleteAlbum(id: String!): DeleteResponse!
}

type MovieData {
  title: String!
  director: String
  year: Int
  genre: String
  posterUrl: String
  plot: String
  source: String!  # "omdb", "upc_database"
}

type AlbumData {
  artist: String
  album: String
  year: Int
  label: String
  genres: [String!]
  coverUrl: String
  tracks: [TrackData!]
  source: String!  # "discogs", "musicbrainz", "itunes"
}

type TrackData {
  title: String!
  trackNumber: Int
  durationSeconds: Int
}

type Health {
  status: String!
  version: String!
  uptime: Int!
}

# Input types for mutations
input SaveMovieInput {
  title: String!
  director: String
  year: Int
  genre: String
  coverUrl: String  # Optional - will be auto-fetched if missing
}

input UpdateMovieInput {
  title: String
  director: String
  year: Int
  genre: String
  coverUrl: String
}

input SaveAlbumInput {
  artist: String!
  album: String!
  year: Int
  label: String
  color_variants: [String!]
  genres: [String!]
  coverUrl: String  # Optional - will be auto-fetched if missing
}

input UpdateAlbumInput {
  artist: String
  album: String
  year: Int
  label: String
  color_variants: [String!]
  genres: [String!]
  coverUrl: String
}

# Response types for mutations
type SaveMovieResponse {
  success: Boolean!
  id: Int
  movie: SavedMovie
  error: String
}

type UpdateMovieResponse {
  success: Boolean!
  movie: Movie
  error: String
}

type SaveAlbumResponse {
  success: Boolean!
  id: Int
  album: SavedAlbum
  error: String
}

type UpdateAlbumResponse {
  success: Boolean!
  album: Album
  error: String
}

type DeleteResponse {
  success: Boolean!
  error: String
}

# Saved data types (from Hasura)
type SavedMovie {
  id: Int!
  title: String!
  director: String
  year: Int
  genre: String
  coverUrl: String
}

type SavedAlbum {
  id: Int!
  artist: String!
  album: String!
  year: Int
  label: String
  color_variants: [String!]
  genres: [String!]
  coverUrl: String
}

# User type
type User {
  id: String!
  email: String!
  createdAt: String!
  updatedAt: String!
  movies: [Movie!]!  # Movies in this user's collection
  albums: [Album!]!  # Albums in this user's collection
}

# Database list types (from Hasura queries)
# Movies and Albums are shared entities - multiple users can have the same movie/album in their collection
type Movie {
  id: String!  # UUID from Hasura
  title: String!
  director: String
  year: Int
  genre: String
  coverUrl: String
  createdAt: String
  updatedAt: String
}

type Album {
  id: String!  # UUID from Hasura
  artist: String!
  album: String!
  year: Int
  label: String
  color_variants: [String!]
  genres: [String!]
  coverUrl: String
  createdAt: String
  updatedAt: String
}

# Auth response types
type RequestLoginCodeResponse {
  success: Boolean!
  message: String!
  error: String
}

type VerifyLoginCodeResponse {
  success: Boolean!
  token: String
  user: User
  error: String
}
